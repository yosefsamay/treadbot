# --- תא ראשון: התקנת ספריות ---
!pip install yfinance ta xgboost --quiet

# --- תא שני: ייבוא ספריות והגדרות ---
import pandas as pd
import numpy as np
import random
import os
import tensorflow as tf
from datetime import datetime
import yfinance as yf
from ta.momentum import RSIIndicator, ROCIndicator
from ta.trend import MACD
from ta.volatility import AverageTrueRange, BollingerBands
from ta.volume import OnBalanceVolumeIndicator
from sklearn.model_selection import train_test_split
from xgboost import XGBClassifier
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
from google.colab import files

%matplotlib inline

def set_seeds(seed=42):
    np.random.seed(seed)
    random.seed(seed)
    tf.random.set_seed(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)

set_seeds()

LOOKAHEAD = 5

# --- תא שלישי: הגדרת פונקציות ---
def get_large_cap_tickers(min_market_cap=1e9):
    tickers = pd.read_html("https://en.wikipedia.org/wiki/List_of_S%26P_500_companies")[0]['Symbol'].tolist()
    filtered = []
    for t in tickers:
        try:
            info = yf.Ticker(t).info
            if 'marketCap' in info and info['marketCap'] is not None and info['marketCap'] >= min_market_cap:
                filtered.append(t)
        except:
            continue
    return filtered

def download_data_yahoo(tickers, period='3y'):
    data = yf.download(tickers, period=period, auto_adjust=True, group_by='ticker')
    adj_close = pd.concat({ticker: data[ticker]['Close'] for ticker in tickers if ticker in data}, axis=1)
    volume = pd.concat({ticker: data[ticker]['Volume'] for ticker in tickers if ticker in data}, axis=1)
    return adj_close, volume

def create_features(df, volume_series, vix):
    features = pd.DataFrame(index=df.index)
    features['price'] = df
    features['returns'] = df.pct_change()
    features['sma_20'] = df.rolling(window=20).mean()
    features['sma_50'] = df.rolling(window=50).mean()
    features['sma_ratio'] = features['sma_20'] / features['sma_50']
    features['volatility'] = df.pct_change().rolling(window=20).std()
    features['macd'] = MACD(df).macd_diff()
    features['rsi'] = RSIIndicator(df).rsi()
    features['momentum'] = ROCIndicator(df).roc()
    features['momentum_signal'] = (features['momentum'] > 0).astype(int).rolling(window=5).mean()
    features['atr'] = AverageTrueRange(df, df, df).average_true_range()

    bb = BollingerBands(df)
    features['bb_bbm'] = bb.bollinger_mavg()
    features['bb_bbh'] = bb.bollinger_hband()
    features['bb_bbl'] = bb.bollinger_lband()
    features['bb_width'] = bb.bollinger_wband()

    obv = OnBalanceVolumeIndicator(close=df, volume=volume_series)
    features['obv'] = obv.on_balance_volume()

    features['open'] = df.shift(1)
    features['close'] = df
    features['prev_close'] = df.shift(1)
    features['gap_pct'] = (features['open'] - features['prev_close']) / features['prev_close']
    features['is_gap'] = (features['gap_pct'].abs() > 0.03).astype(int)
    features['gap_direction'] = np.where(features['gap_pct'] > 0, 1, np.where(features['gap_pct'] < 0, -1, 0))
    features['candle_signal'] = np.where(abs(features['close'] - features['open']) < 0.002 * features['open'], 0, np.where(features['close'] > features['open'], 1, -1))
    features['volume'] = volume_series
    features['volume_sma_20'] = volume_series.rolling(window=20).mean()
    features['volume_ratio'] = volume_series / features['volume_sma_20']

    # --- הוספת מדד VIX ---
    vix_aligned = vix.reindex(features.index).fillna(method='ffill')
    features['vix'] = vix_aligned
    features['vix_scaled'] = features['vix'] / (features['volatility'] + 1e-6)
    features['vix_corr'] = features['returns'].rolling(30).corr(vix_aligned)

    future_returns = (df.shift(-LOOKAHEAD) - df) / df
    features['target'] = np.where(future_returns > 0.02, 1, np.where(future_returns < -0.02, 0, np.nan))
    return features.dropna()

def train_xgboost(X_train, y_train):
    model = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)
    model.fit(X_train, y_train)
    return model

def train_lstm(X, y):
    model = Sequential()
    model.add(LSTM(50, input_shape=(X.shape[1], X.shape[2]), return_sequences=True))
    model.add(Dropout(0.2))
    model.add(LSTM(50))
    model.add(Dropout(0.2))
    model.add(Dense(1, activation='sigmoid'))
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    model.fit(X, y, epochs=5, batch_size=32, verbose=0)
    return model

def recommend_stocks(adj_close_data, volume_data, vix):
    recommendations = []
    for ticker in adj_close_data.columns:
        prices = adj_close_data[ticker].dropna()
        volume = volume_data[ticker].dropna()
        if len(prices) < 200 or len(volume) < 200:
            continue

        # סינון לפי נזילות
        volume_mean = volume[-20:].mean()
        price_mean = prices[-20:].mean()
        dollar_volume = volume_mean * price_mean
        if volume_mean < 300_000 or dollar_volume < 5_000_000:
            continue

        features = create_features(prices, volume, vix)
        X = features.drop(['target', 'price'], axis=1)
        y = features['target']
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)
        X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, shuffle=False, random_state=42)
        xgb_model = train_xgboost(X_train, y_train)
        lstm_X = X_train.reshape((X_train.shape[0], 1, X_train.shape[1]))
        lstm_model = train_lstm(lstm_X, y_train)
        X_live = X_scaled[-1:]
        lstm_input = X_live.reshape((1, 1, X_live.shape[1]))
        xgb_prob = xgb_model.predict_proba(X_live)[0, 1]
        lstm_prob = lstm_model.predict(lstm_input)[0, 0]
        avg_prob = (xgb_prob + lstm_prob) / 2
        confidence = abs(avg_prob - 0.5)
        direction = "LONG" if avg_prob > 0.5 else "SHORT"
        price_now = prices.iloc[-1]
        if avg_prob > 0.80 or avg_prob < 0.20:
            print(f"\u05d4\u05de\u05dc\u05e6\u05ea {direction} \u05e2\u05dc {ticker} \u05d1\u05de\u05d7\u05d9\u05e8 {price_now:.2f} | \u05d4\u05e1\u05ea\u05d1\u05e8\u05d5\u05ea: {avg_prob:.2f}, \u05d1\u05d9\u05d8\u05d7\u05d5\u05df: {confidence:.2f}")
            recommendations.append((ticker, direction, round(avg_prob, 3), round(confidence, 3)))
    recommendations.sort(key=lambda x: x[3], reverse=True)
    return recommendations

def save_recommendations(recommendations):
    df = pd.DataFrame(recommendations, columns=['Ticker', 'Direction', 'Probability', 'Confidence'])
    filename = f"recommendations_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.csv"
    df.to_csv('/content/' + filename, index=False)
    files.download('/content/' + filename)
    print(f"Recommendations saved to {filename}")

# --- תא אחרון: הרצת המודל ---
tickers = get_large_cap_tickers(min_market_cap=1e9)[:150]  # בחירה של עד 150 מתוך ה-S&P 500
adj_close_data, volume_data = download_data_yahoo(tickers)
vix = yf.download('^VIX', start=adj_close_data.index.min(), end=adj_close_data.index.max())['Close']

if adj_close_data.empty:
    print("לא נמצאו נתונים היסטוריים.")
else:
    print("Loaded data for", len(adj_close_data.columns), "tickers")
    best_stocks = recommend_stocks(adj_close_data, volume_data, vix)
    print("Stock Recommendations:")
    for ticker, direction, prob, confidence in best_stocks:
        print(f"{ticker}: {direction} (prob={prob}, confidence={confidence})")
    if best_stocks:
        save_recommendations(best_stocks)
